锁: 将多个线程对共享数据的访问转换为串行执行，一个共享数据一次只能被一个线程访问，该线程访问结束后其他线程才能对其访问;

具体锁:
    1.synchronzied: 内部锁，非公平锁，可重入锁，互斥锁
    2.ReentrantLock: 显示锁，默认非公平锁(可以设置为公平锁和非公平锁)，可重入锁
        常用方法: lock,unlock,tryLock(尝试申请Lock实例锁表示的锁),isLocked,getQueueLength(检查锁的等待线程的数量)
    3.ReentrantReadWriteLock: 读写锁，可重入锁;
        常用方法: readLock(返回读取操作的锁),writeLock(返回写入操作的锁)
    

临界区: 锁的持有线程在其获得锁和释放锁这段时间内执行的代码。临界区一次只能被一个线程访问;

锁分类:

锁: 互斥锁(又叫排他锁或者独占锁，一个锁一次只能被一个线程持有)和自旋锁属于基本锁，其他锁基于这两个锁实现;
互斥锁:![img.png](img.png) 

读写锁(共享排他锁): 允许多个线程同时读取共享变量，但是一次只允许一个线程对一个变量进行更新;  
![img_1.png](img_1.png)  
读写锁使用场景:
    1.只读操作比写操作要频繁的多;
    2.读线程持有锁的时间较长;
锁的降级: 一个线程持有读写锁的写锁的情况下可以继续获得相应的读锁;
锁的升级: 一个线程持有读写锁的读锁的情况下可以继续获得相应的写锁;

可重入锁: 一个线程在其持有一个锁的时候能再次申请此锁;

按锁的调度策略:
    公平锁: 会按照排队顺序依次获取锁;
    非公平锁: 多个线程获取同一把锁时，不会按照先后的排队顺序依次获取该锁，而是随机的;

按锁的实现方式:
    内部锁(范围: 在一个方法内): synchronized关键字实现的，属于非公平锁;
    显示锁(可以在多个方法中): 通过java.util.concurrent.locks.Lock接口的实现类实现，可以设置为公平锁和非公平锁;

按上锁时机:
    悲观锁: 线程访问共享资源时，会先上锁;
        1.互斥锁;
        2.自旋锁;
        3.读写锁(写锁): 由读锁和写锁两部分构成;
            1.读优先锁;
            2.写优先锁;
            3.公平读写锁;
    乐观锁: 先修改资源，再验证资源有没有发生冲突(其他线程有没有修改)。没有冲突，修改完成。有冲突，放弃修改。全程不会加锁;   

按互斥性:
    独占锁: 一个线程获取锁时，其他线程不能获取锁;
        1.互斥锁;
        2.自旋锁;
        3.读写锁(写锁): 由读锁和写锁两部分构成;
            1.读优先锁;
            2.写优先锁;
            3.公平读写锁;
    共享锁: 多个线程可以共享同一把锁;
        1.读写锁(读锁);